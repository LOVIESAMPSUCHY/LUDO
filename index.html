<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Ludo Club ‚Äì Mateusz Edition (rozszerzone)</title>
<style>
  :root {
    --bg: #0f1220;
    --panel: #181b2e;
    --text: #e8e8ef;
    --muted: #a9acc6;
    --accent: #7d7fff;
    --safe: #e9ecf7;
  }
  * { box-sizing: border-box }
  body {
    margin: 0;
    background: radial-gradient(1200px 600px at 70% -10%, #18203c, #0c0f1c 55%, #070a14 100%);
    color: var(--text);
    font-family: ui-sans-serif, Inter, Segoe UI, Roboto, Arial, sans-serif;
  }
  header {
    display:flex; gap:16px; align-items:center; justify-content:center;
    padding:14px 10px; background: #0a0d1a; position:sticky; top:0; z-index:10; border-bottom:1px solid #10142a;
  }
  header .title { font-weight:800; letter-spacing:.4px; }
  .wrap {
    display:grid; grid-template-columns: 1fr 380px; gap:16px; padding:16px; max-width:1400px; margin:0 auto;
  }
  #boardWrap {
    background: #0b0f1f; border:1px solid #121733; border-radius:16px; padding:16px;
    display:flex; align-items:center; justify-content:center;
    box-shadow: 0 20px 80px rgba(0,0,0,.35), inset 0 0 40px #0a0d1a;
  }
  #gameCanvas { background: #ffffff; border-radius:12px; width: min(92vw, 900px); height: auto; aspect-ratio: 1/1; image-rendering: crisp-edges; }
  #side {
    background: var(--panel); border:1px solid #202647; border-radius:16px; padding:16px;
    display:flex; flex-direction:column; gap:14px;
  }
  .row { display:flex; align-items:center; gap:12px; flex-wrap: wrap; }
  label { color: var(--muted); font-size:14px; }
  select, button, input[type="checkbox"] {
    background:#0e1330; color:var(--text); border:1px solid #2a3163; border-radius:12px; padding:10px 12px; font-size:14px;
  }
  button { cursor:pointer; transition: .2s transform, .2s opacity; }
  button:hover { transform: translateY(-1px); }
  button:disabled { opacity: .5; cursor:not-allowed; transform:none; }
  .pill {
    background:#0e1330; border:1px solid #222a56; border-radius:999px; padding:6px 10px; font-size:12px; color:#c6c9e6;
  }
  .status {
    background:#0d1231; border:1px solid #262f67; border-radius:12px; padding:12px; line-height:1.35; font-size:14px;
  }
  .hint { color:#9aa2d0; font-size:12px; }
  .legend { display:grid; grid-template-columns:repeat(4,1fr); gap:8px; }
  .dot { width:14px; height:14px; border-radius:50%; display:inline-block; vertical-align:middle; margin-right:6px; border:1px solid rgba(0,0,0,.25)}
  .c-red{ background:#e74c3c}
  .c-blue{ background:#3498db}
  .c-green{ background:#2ecc71}
  .c-yellow{ background:#f1c40f}
  .flex { display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  .grow { flex:1 }
  .k6 {
    width:42px; height:42px; border-radius:8px; background:#fff; border:2px solid #111; display:grid; place-items:center; font-weight:800; color:#111;
  }
  .bar {
    height:8px; background:#0f1440; border:1px solid #202762; border-radius:999px; overflow:hidden;
  }
  .bar > div { height:100%; background: linear-gradient(90deg, #6a74ff, #9c6bff); width:0% }
  .sep { height:1px; background:#1a1f3f; margin:6px 0 }
  footer { text-align:center; color:#8f95bd; font-size:12px; padding:8px 0 16px}
</style>
</head>
<body>
  <header>
    <div class="title">üé≤ Ludo Club ‚Äî <strong>Mateusz Edition</strong></div>
    <span class="pill">Offline ‚Ä¢ Jednoplikowe</span>
    <span class="pill">2‚Äì4 graczy</span>
    <span class="pill">Kliknij pionek, ≈ºeby wykonaƒá ruch</span>
  </header>

  <div class="wrap">
    <div id="boardWrap">
      <canvas id="gameCanvas" width="900" height="900"></canvas>
    </div>

    <aside id="side">
      <div class="row">
        <label>üßë‚Äçü§ù‚Äçüßë Liczba graczy</label>
        <select id="playersSelect">
          <option value="2">2</option>
          <option value="3">3</option>
          <option value="4" selected>4</option>
        </select>
        <button id="restartBtn">üîÅ Nowa gra</button>
      </div>

      <div class="row">
        <button id="rollBtn">üé≤ Rzuƒá kostkƒÖ</button>
        <div class="k6" id="dieFace">‚Äì</div>
        <label class="flex" title="Je≈õli w≈ÇƒÖczone: 2 pionki tej samej dru≈ºyny mogƒÖ staƒá na jednym polu bez ryzyka bicia.">
          <input type="checkbox" id="stacking" checked/> Zezw√≥l na ‚Äûwie≈ºe‚Äù (stack)
        </label>
      </div>

      <div class="status" id="statusBox">
        Tura: <strong id="turnName">Czerwony</strong><br/>
        Rzut: <strong id="rollInfo">‚Äì</strong><br/>
        <span class="hint">Rzuƒá ko≈õciƒÖ, a potem kliknij mo≈ºliwy pionek (pod≈õwietlony).</span>
      </div>

      <div>
        <div class="row"><strong>Postƒôp do zwyciƒôstwa</strong></div>
        <div class="row"><span class="dot c-red"></span> Czerwony <div class="bar grow"><div id="pbar0"></div></div></div>
        <div class="row"><span class="dot c-blue"></span> Niebieski <div class="bar grow"><div id="pbar1"></div></div></div>
        <div class="row"><span class="dot c-green"></span> Zielony <div class="bar grow"><div id="pbar2"></div></div></div>
        <div class="row"><span class="dot c-yellow"></span> ≈ª√≥≈Çty <div class="bar grow"><div id="pbar3"></div></div></div>
      </div>

      <div class="sep"></div>
      <div>
        <strong>Legenda</strong>
        <div class="legend">
          <div><span class="dot" style="background:#fff;border:1px solid #ccc"></span> Pole zwyk≈Çe</div>
          <div><span class="dot" style="background:var(--safe)"></span> Pole bezpieczne</div>
          <div><span class="dot c-red"></span> Start czerwony</div>
          <div><span class="dot c-blue"></span> Start niebieski</div>
          <div><span class="dot c-green"></span> Start zielony</div>
          <div><span class="dot c-yellow"></span> Start ≈º√≥≈Çty</div>
        </div>
      </div>
    </aside>
  </div>

  <footer>Made with ‚ù§Ô∏è for Mateusz ‚Ä¢ Zasady: 6 = wyj≈õcie na start + dodatkowy rzut; bicie wysy≈Ça przeciwnika do bazy; bezpieczne pola sƒÖ nietykalne.</footer>

<script>
/** =========================
 *   LUDO ‚Äì Mateusz Edition
 *   Jednoplikowa implementacja
 *   Autor: ChatGPT (dla Mateusza)
 * ==========================*/

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const UI = {
  rollBtn: document.getElementById('rollBtn'),
  dieFace: document.getElementById('dieFace'),
  statusBox: document.getElementById('statusBox'),
  turnName: document.getElementById('turnName'),
  rollInfo: document.getElementById('rollInfo'),
  playersSelect: document.getElementById('playersSelect'),
  restartBtn: document.getElementById('restartBtn'),
  stacking: document.getElementById('stacking'),
  pbars: [
    document.getElementById('pbar0'),
    document.getElementById('pbar1'),
    document.getElementById('pbar2'),
    document.getElementById('pbar3'),
  ]
};

// Kolory dru≈ºyn
const COLORS = ['#e74c3c', '#3498db', '#2ecc71', '#f1c40f'];
const COLOR_NAMES = ['Czerwony', 'Niebieski', 'Zielony', '≈ª√≥≈Çty'];

// Ustawienia planszy (uk≈Çad ≈õcie≈ºki ‚Äì 52 pola g≈Ç√≥wne + 6 domowych na gracza)
const GRID = 15;
const CS = canvas.width / GRID; // cell size

// Wsp√≥≈Çrzƒôdne g≈Ç√≥wnego pier≈õcienia 52 p√≥l (id 0..51):
// Budujemy ‚Äûramkƒô‚Äù dooko≈Ça (bez naro≈ºnych duplikat√≥w), zgodnƒÖ z ruchem zgodnie z ruchem wskaz√≥wek zegara.
function ringPath() {
  const pts = [];
  const min = 1, max = GRID - 2; // 13
  // top row left->right
  for (let x=min; x<=max; x++) pts.push([x, min]);
  // right col top->bottom
  for (let y=min+1; y<=max; y++) pts.push([max, y]);
  // bottom row right->left
  for (let x=max-1; x>=min; x--) pts.push([x, max]);
  // left col bottom->top
  for (let y=max-1; y>min; y--) pts.push([min, y]);
  // To da  (max-min+1)*4 - 4  = 13*4 - 4 = 48 ‚Äì dorobimy jeszcze 4 ‚Äûwypustki‚Äù, ≈ºeby by≈Ço 52.
  // Dodajmy po jednym polu w po≈Çowie ka≈ºdej krawƒôdzi w kierunku ≈õrodka:
  pts.splice(13, 0, [max-1, min+1]);     // g√≥rna wypustka
  pts.splice(26+1, 0, [max-1, max-1]);   // prawa wypustka
  pts.splice(39+2, 0, [min+1, max-1]);   // dolna wypustka
  pts.splice(52, 0, [min+1, min+1]);     // lewa wypustka (ko≈Ñcowy push na koniec)
  // Je≈õli wypad≈Ço >52, przytnijmy
  return pts.slice(0,52);
}
const RING = ringPath();

// ‚ÄûStart‚Äù ka≈ºdego gracza ‚Äì indeks na pier≈õcieniu
// Ustalamy: Red=0 (top-lewa), Blue=13 (top-right), Green=26 (bottom-right), Yellow=39 (bottom-left)
const START_INDEX = [0, 13, 26, 39];

// Bezpieczne pola (zwykle to starty i kilka sta≈Çych)
const SAFE_INDICES = new Set([...START_INDEX, 8, 21, 34, 47]); // 5 ‚Äûkrzy≈ºowych‚Äù + starty

// ≈öcie≈ºka domowa (6 p√≥l) dla ka≈ºdego gracza ‚Äì wzd≈Çu≈º ‚Äûpromienia‚Äù do centrum
// Bierzemy punkt startowy i idziemy w stronƒô ≈õrodka; ko≈Ñczymy w centrum.
function homePathFor(player) {
  const [sx, sy] = RING[START_INDEX[player]];
  // kierunek do ≈õrodka
  const cx = Math.floor(GRID/2), cy = Math.floor(GRID/2);
  const dx = Math.sign(cx - sx), dy = Math.sign(cy - sy);
  const arr = [];
  // 6 p√≥≈Ç do ‚Äûdomu‚Äù (ostatnie to meta)
  let x = sx, y = sy;
  for (let i=1; i<=6; i++) {
    x += dx; y += dy;
    arr.push([x, y]);
  }
  return arr;
}
const HOME_PATHS = [0,1,2,3].map(homePathFor);

// Bazy (4 pola) ‚Äì gdzie stojƒÖ pionki na starcie przed wyj≈õciem
const BASE_CELLS = [
  // RED (lewy g√≥rny kwadrat 3x3)
  [[2,2],[3,2],[2,3],[3,3]],
  // BLUE (prawy g√≥rny)
  [[GRID-3,2],[GRID-4,2],[GRID-3,3],[GRID-4,3]],
  // GREEN (lewy dolny)
  [[2,GRID-3],[3,GRID-3],[2,GRID-4],[3,GRID-4]],
  // YELLOW (prawy dolny)
  [[GRID-3,GRID-3],[GRID-4,GRID-3],[GRID-3,GRID-4],[GRID-4,GRID-4]],
];

const TOKENS_PER_PLAYER = 4;

// Stan gry
let state = null;

// Inicjalizacja nowej gry
function newGame(playersCount = 4) {
  state = {
    playersCount,
    current: 0,         // indeks gracza
    die: null,          // wynik rzutu
    rolled: false,      // czy rzucono w tej turze
    extraTurn: false,   // czy kolejny rzut za ‚Äû6‚Äù
    winner: null,
    stackingAllowed: UI.stacking.checked,
    tokens: [],         // {player, posType:'base'|'ring'|'home', ringIndex, homeIndex, baseSlot}
  };
  for (let p=0; p<playersCount; p++) {
    for (let i=0; i<TOKENS_PER_PLAYER; i++) {
      state.tokens.push({
        player: p,
        posType: 'base',
        ringIndex: null,
        homeIndex: null,
        baseSlot: i
      });
    }
  }
  UI.dieFace.textContent = '‚Äì';
  UI.rollInfo.textContent = '‚Äì';
  UI.turnName.textContent = COLOR_NAMES[state.current];
  draw();
  updateProgressBars();
}

// Rzut kostkƒÖ
function rollDie() {
  if (state.winner != null) return;
  if (state.rolled) return;
  const n = Math.floor(Math.random()*6)+1;
  state.die = n;
  state.rolled = true;
  UI.dieFace.textContent = n;
  UI.rollInfo.textContent = n;
  // Auto-podpowied≈∫: je≈õli brak ruch√≥w ‚Äì przechodzimy turƒô (po kr√≥tkim flashu)
  const moves = legalMovesFor(state.current, n);
  if (moves.length === 0) {
    flashStatus(`Brak legalnych ruch√≥w dla gracza ${COLOR_NAMES[state.current]}.`);
    setTimeout(nextTurn, 700);
  } else {
    flashStatus(`Wybierz pionek do ruchu (${COLOR_NAMES[state.current]}).`);
  }
  draw();
}

// Sprawd≈∫ ruchy legalne dla danego gracza i wyniku
function legalMovesFor(player, die) {
  const res = [];
  const startIdx = START_INDEX[player];

  for (let i=0; i<state.tokens.length; i++) {
    const t = state.tokens[i];
    if (t.player !== player) continue;

    if (t.posType === 'base') {
      // Wyj≈õcie tylko na 6
      if (die === 6) {
        const targetRing = startIdx;
        // Sprawd≈∫ czy pole startowe dostƒôpne (stacking? bicie?)
        if (canLandOnRing(player, targetRing)) {
          res.push({tokenIndex:i, type:'enter', toRingIndex: targetRing});
        }
      }
    } else if (t.posType === 'ring') {
      const newRing = (t.ringIndex + die) % RING.length;
      // Sprawd≈∫, czy przekraczamy start -> wchodzimy do home?
      // Logika: je≈õli przechodzimy przez w≈Çasny start i mamy nadmiar, wchodzimy w ≈õcie≈ºkƒô domowƒÖ.
      const stepsToStart = ( (START_INDEX[player] - t.ringIndex - 1 + RING.length) % RING.length ) + 1;
      if (die > stepsToStart) {
        // liczba krok√≥w po starcie do home
        const inHomeSteps = die - stepsToStart - 1; // -1 bo pole ‚Äûza startem‚Äù to 0 w home
        if (inHomeSteps <= 5) { // homeIndex 0..5
          // LƒÖdowanie w home
          if (canLandInHome(player, inHomeSteps)) {
            res.push({tokenIndex:i, type:'tohome', toHomeIndex: inHomeSteps});
          }
        }
      } else {
        // Normalne przesuniƒôcie po pier≈õcieniu
        if (canLandOnRing(player, newRing)) {
          res.push({tokenIndex:i, type:'move', toRingIndex: newRing});
        }
      }
    } else if (t.posType === 'home') {
      // Poruszanie w domu ‚Äì tylko je≈õli nie wyjdziemy poza meta
      const target = t.homeIndex + die;
      if (target <= 5 && canLandInHome(player, target)) {
        res.push({tokenIndex:i, type:'homeMove', toHomeIndex: target});
      }
    }
  }
  return res;
}

// Czy mo≈ºemy stanƒÖƒá na polu ringowym (uwzglƒôdniajƒÖc bicie i stackowanie)
function canLandOnRing(player, ringIndex) {
  const occupants = tokensOnRing(ringIndex);
  if (occupants.length === 0) return true;
  // je≈õli zajƒôte przez naszych:
  const sameTeam = occupants.every(ti => state.tokens[ti].player === player);
  if (sameTeam) {
    return state.stackingAllowed; // je≈õli stack dozwolony ‚Äì ok, inaczej blok
  }
  // zajƒôte przez przeciwnika ‚Äì czy to bezpieczne?
  if (SAFE_INDICES.has(ringIndex)) return false;
  // bicie dozwolone
  return true;
}

function canLandInHome(player, homeIndex) {
  // Je≈ºeli w home ju≈º stoi nasz pionek na tym indeksie ‚Äì blok
  const occ = tokensInHome(player, homeIndex);
  return occ.length === 0;
}

function tokensOnRing(ringIndex) {
  const out = [];
  for (let i=0; i<state.tokens.length; i++) {
    const t = state.tokens[i];
    if (t.posType === 'ring' && t.ringIndex === ringIndex) out.push(i);
  }
  return out;
}
function tokensInHome(player, homeIndex) {
  const out = [];
  for (let i=0; i<state.tokens.length; i++) {
    const t = state.tokens[i];
    if (t.player === player && t.posType === 'home' && t.homeIndex === homeIndex) out.push(i);
  }
  return out;
}

// Wykonaj ruch (z animacjƒÖ)
let animating = false;

async function performMove(move) {
  if (animating || state.winner != null) return;
  animating = true;

  const t = state.tokens[move.tokenIndex];
  const die = state.die;

  if (move.type === 'enter') {
    // wjazd ze stanu base na start
    await animateBaseToRing(move.tokenIndex, START_INDEX[t.player]);
    t.posType = 'ring';
    t.ringIndex = START_INDEX[t.player];
    t.homeIndex = null;
    // bicie na starcie (je≈õli przeciwnik stoi i pole nie jest safe ‚Äì ale start jest safe, wiƒôc nie bijemy)
  } else if (move.type === 'move') {
    await animateRingAdvance(move.tokenIndex, die);
    t.ringIndex = move.toRingIndex;
  } else if (move.type === 'tohome') {
    // przeskok przez start ‚Äì do homeIndex
    // animuj do startu, a potem ‚Äûdo ≈õrodka‚Äù
    const stepsToStart = ( (START_INDEX[t.player] - t.ringIndex - 1 + RING.length) % RING.length ) + 1;
    if (stepsToStart>0) await animateRingAdvance(move.tokenIndex, stepsToStart);
    await animateEnterHome(move.tokenIndex, move.toHomeIndex);
    t.posType = 'home';
    t.ringIndex = null;
    t.homeIndex = move.toHomeIndex;
  } else if (move.type === 'homeMove') {
    await animateHomeAdvance(move.tokenIndex, t.homeIndex, move.toHomeIndex);
    t.homeIndex = move.toHomeIndex;
  }

  // Bic-ie na polu ringowym (je≈õli lƒÖdujemy na przeciwniku i nie jest to bezpieczne)
  if (t.posType === 'ring') {
    const occ = tokensOnRing(t.ringIndex);
    const enemies = occ.filter(i => state.tokens[i].player !== t.player);
    if (enemies.length > 0 && !SAFE_INDICES.has(t.ringIndex)) {
      // Wybij wszystkich przeciwnik√≥w z tego pola
      for (const ei of enemies) {
        sendTokenToBase(ei);
      }
      flashStatus(`üí• ${COLOR_NAMES[t.player]} bije przeciwnika na polu!`);
    }
  }

  // Sprawd≈∫ zwyciƒôstwo (wszystkie 4 pionki w homeIndex=5)
  if (checkWin(t.player)) {
    state.winner = t.player;
    flashStatus(`üèÜ Wygrywa ${COLOR_NAMES[t.player]}!`);
  }

  // Kolej tury
  const wasSix = (state.die === 6);
  state.die = null;
  state.rolled = false;

  if (wasSix && state.winner == null) {
    flashStatus(`${COLOR_NAMES[state.current]} ma dodatkowy rzut za ‚Äû6‚Äù.`);
    // nie zmieniamy current
  } else {
    nextTurn();
  }

  updateProgressBars();
  animating = false;
  draw();
}

function checkWin(player) {
  let ok = 0;
  for (const t of state.tokens) {
    if (t.player===player && t.posType==='home' && t.homeIndex===5) ok++;
  }
  return ok === TOKENS_PER_PLAYER;
}

function sendTokenToBase(tokenIndex) {
  const t = state.tokens[tokenIndex];
  // przenie≈õ do pierwszego wolnego slotu bazy
  const used = new Set(
    state.tokens.filter(x=>x.player===t.player && x.posType==='base').map(x=>x.baseSlot)
  );
  let slot = 0;
  while (used.has(slot) && slot<4) slot++;
  t.posType = 'base';
  t.ringIndex = null;
  t.homeIndex = null;
  t.baseSlot = slot%4;
}

function nextTurn() {
  if (state.winner!=null) return;
  state.current = (state.current + 1) % state.playersCount;
  UI.turnName.textContent = COLOR_NAMES[state.current];
  UI.rollInfo.textContent = '‚Äì';
  UI.dieFace.textContent = '‚Äì';
}

// Animacje (proste, interpolowane pozycje)
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

async function animateBaseToRing(tokenIndex, ringIndex) {
  await animateTokenJump(tokenIndex, getTokenPixelPosFromState(tokenIndex), cellCenter(RING[ringIndex]));
}

async function animateRingAdvance(tokenIndex, steps) {
  const t = state.tokens[tokenIndex];
  for (let s=0; s<steps; s++) {
    const next = (t.ringIndex + 1) % RING.length;
    await animateTokenJump(tokenIndex, cellCenter(RING[t.ringIndex]), cellCenter(RING[next]));
    t.ringIndex = next;
    draw(); await sleep(60);
  }
}

async function animateEnterHome(tokenIndex, toHomeIndex) {
  const t = state.tokens[tokenIndex];
  const path = HOME_PATHS[t.player];
  // pierwszy indeks home to 0
  await animateTokenJump(tokenIndex, cellCenter(RING[START_INDEX[t.player]]), cellCenter(path[0]));
  for (let i=1;i<=toHomeIndex;i++){
    await animateTokenJump(tokenIndex, cellCenter(path[i-1]), cellCenter(path[i]));
    draw(); await sleep(60);
  }
}

async function animateHomeAdvance(tokenIndex, from, to) {
  const t = state.tokens[tokenIndex];
  const p = HOME_PATHS[t.player];
  for (let i=from+1; i<=to; i++) {
    await animateTokenJump(tokenIndex, cellCenter(p[i-1]), cellCenter(p[i]));
    draw(); await sleep(60);
  }
}

// Skokowa interpolacja (bez trajektorii ≈Çukowej ‚Äì lekki podskok przez cie≈Ñ)
async function animateTokenJump(tokenIndex, fromPix, toPix) {
  const steps = 10;
  for (let i=1; i<=steps; i++) {
    const k = i/steps;
    const x = fromPix[0] + (toPix[0]-fromPix[0])*k;
    const y = fromPix[1] + (toPix[1]-fromPix[1])*k;
    draw({ghostToken: {tokenIndex, x, y}});
    await sleep(10);
  }
}

// Pozycje pikselowe
function cellCenter([gx,gy]) {
  return [gx*CS + CS/2, gy*CS + CS/2];
}
function baseCellCenter(player, baseSlot) {
  const [gx,gy] = BASE_CELLS[player][baseSlot];
  return cellCenter([gx,gy]);
}
function getTokenPixelPosFromState(i) {
  const t = state.tokens[i];
  if (t.posType === 'base') return baseCellCenter(t.player, t.baseSlot);
  if (t.posType === 'ring') return cellCenter(RING[t.ringIndex]);
  if (t.posType === 'home') return cellCenter(HOME_PATHS[t.player][t.homeIndex]);
}

// Rysowanie planszy
function draw(opts={}) {
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // Siatka
  ctx.save();
  ctx.strokeStyle = '#d7daee';
  ctx.lineWidth = 1;
  for (let i=0;i<GRID;i++) {
    // ramka
    ctx.strokeRect(i*CS, 0, CS, canvas.height);
    ctx.strokeRect(0, i*CS, canvas.width, CS);
  }
  ctx.restore();

  // Pola pier≈õcienia
  for (let i=0; i<RING.length; i++) {
    const [gx,gy] = RING[i];
    const x = gx*CS, y = gy*CS;
    ctx.fillStyle = SAFE_INDICES.has(i) ? '#eef2ff' : '#ffffff';
    ctx.strokeStyle = '#999';
    roundRect(ctx, x+2, y+2, CS-4, CS-4, 6, true, true);
    if (SAFE_INDICES.has(i)) {
      ctx.fillStyle = '#cfd7ff';
      ctx.globalAlpha = .25;
      ctx.beginPath(); ctx.arc(x+CS/2,y+CS/2, CS*.25, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1;
    }
  }

  // Pola domowe
  for (let p=0;p<state.playersCount;p++) {
    for (let h=0; h<6; h++) {
      const [gx,gy] = HOME_PATHS[p][h];
      const x = gx*CS, y = gy*CS;
      ctx.fillStyle = h===5? shade(COLORS[p], 0.2) : '#f8f9ff';
      ctx.strokeStyle = '#8892c0';
      roundRect(ctx, x+2, y+2, CS-4, CS-4, 6, true, true);
    }
  }

  // Bazy (4 pola)
  for (let p=0;p<state.playersCount;p++) {
    for (let s=0;s<4;s++) {
      const [gx,gy] = BASE_CELLS[p][s];
      const x = gx*CS, y = gy*CS;
      ctx.fillStyle = '#f7f8ff';
      ctx.strokeStyle = '#b9c0ea';
      roundRect(ctx, x+2, y+2, CS-4, CS-4, 10, true, true);
      // akcent koloru gracza
      ctx.fillStyle = shade(COLORS[p], .1);
      ctx.globalAlpha = .25;
      ctx.beginPath();
      ctx.arc(x+CS/2, y+CS/2, CS*.28, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
  }

  // Startowe pola ‚Äì podmaluj kolorem gracza
  for (let p=0;p<state.playersCount;p++) {
    const [gx,gy] = RING[START_INDEX[p]];
    const x = gx*CS, y = gy*CS;
    ctx.fillStyle = shade(COLORS[p], .2);
    ctx.globalAlpha = .3;
    roundRect(ctx, x+2, y+2, CS-4, CS-4, 8, true, false);
    ctx.globalAlpha = 1;
  }

  // Pod≈õwietlenie mo≈ºliwych ruch√≥w (je≈õli rzut wykonany)
  if (state.rolled && state.winner==null) {
    const moves = legalMovesFor(state.current, state.die);
    const tokenSet = new Set(moves.map(m=>m.tokenIndex));
    for (const ti of tokenSet) {
      const [x,y] = getTokenPixelPosFromState(ti);
      ctx.strokeStyle = '#7d7fff';
      ctx.lineWidth = 4;
      ctx.beginPath(); ctx.arc(x, y, CS*.28, 0, Math.PI*2); ctx.stroke();
    }
  }

  // Pionki
  // Je≈õli jest animacja ‚ÄûghostToken‚Äù ‚Äì ten pionek rysujemy w pozycji duchowej
  const ghost = opts.ghostToken;
  for (let i=0;i<state.tokens.length;i++) {
    const t = state.tokens[i];
    if (t.player >= state.playersCount) continue;
    let [x,y] = getTokenPixelPosFromState(i);
    let alpha = 1;
    if (ghost && ghost.tokenIndex === i) { x = ghost.x; y = ghost.y; alpha = .9; }

    // offset przy stacku ‚Äì u≈Ç√≥≈º ‚Äûwie≈ºƒô‚Äù
    const stack = stackedIndicesAt(t);
    const idxInStack = stack.indexOf(i);
    const offsetY = idxInStack * -6;

    drawPawn(x, y+offsetY, COLORS[t.player], i);
  }

  // Meta ‚Äì ≈õrodek (tylko kosmetyka)
  ctx.save();
  const cx = canvas.width/2, cy = canvas.height/2;
  ctx.globalAlpha = .1;
  ctx.fillStyle = '#6f77ff';
  ctx.beginPath(); ctx.arc(cx, cy, CS*1.6, 0, Math.PI*2); ctx.fill();
  ctx.restore();
}

function stackedIndicesAt(tkn) {
  const t = tkn;
  if (t.posType==='ring') {
    return state.tokens
      .map((tt, i)=>({tt,i}))
      .filter(o=>o.tt.posType==='ring' && o.tt.ringIndex===t.ringIndex && o.tt.player===t.player)
      .map(o=>o.i);
  } else if (t.posType==='home') {
    return state.tokens
      .map((tt, i)=>({tt,i}))
      .filter(o=>o.tt.posType==='home' && o.tt.homeIndex===t.homeIndex && o.tt.player===t.player)
      .map(o=>o.i);
  } else if (t.posType==='base') {
    return state.tokens
      .map((tt, i)=>({tt,i}))
      .filter(o=>o.tt.posType==='base' && o.tt.baseSlot===t.baseSlot && o.tt.player===t.player)
      .map(o=>o.i);
  }
  return [ ];
}

function drawPawn(x,y,color, id) {
  // cie≈Ñ
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,.2)';
  ctx.beginPath(); ctx.ellipse(x, y+10, CS*.22, CS*.10, 0, 0, Math.PI*2); ctx.fill();
  ctx.restore();

  // pionek
  const r = CS*.26;
  const grd = ctx.createRadialGradient(x-r/2, y-r/2, r*.3, x, y, r);
  grd.addColorStop(0, shade(color, .4));
  grd.addColorStop(1, color);
  ctx.fillStyle = grd;
  ctx.strokeStyle = '#111';
  ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill(); ctx.stroke();

  // numer (debug)
  ctx.fillStyle = '#111';
  ctx.font = `${Math.floor(CS*.20)}px ui-sans-serif`;
  ctx.textAlign='center'; ctx.textBaseline='middle';
  // ctx.fillText(String(id%10), x, y);
}

function roundRect(ctx, x, y, w, h, r, fill, stroke) {
  if (w<2*r) r = w/2; if (h<2*r) r = h/2;
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y, x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x, y+h, r);
  ctx.arcTo(x, y+h, x, y, r);
  ctx.arcTo(x, y, x+w, y, r);
  if (fill) ctx.fill(); if (stroke) ctx.stroke();
}

function shade(hex, k) {
  // prosty lighten
  const c = parseInt(hex.slice(1),16);
  let r=(c>>16)&255, g=(c>>8)&255, b=c&255;
  r = Math.min(255, Math.floor(r + (255-r)*k));
  g = Math.min(255, Math.floor(g + (255-g)*k));
  b = Math.min(255, Math.floor(b + (255-b)*k));
  return `rgb(${r},${g},${b})`;
}

function flashStatus(msg) {
  UI.statusBox.innerHTML = `Tura: <strong>${COLOR_NAMES[state.current]}</strong><br/>Rzut: <strong>${state.die ?? '‚Äì'}</strong><br/>${msg}`;
}

// Obs≈Çuga klikniƒôƒá ‚Äì wyb√≥r pionka do ruchu
canvas.addEventListener('click', async (e)=>{
  if (!state.rolled || animating || state.winner!=null) return;
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) * (canvas.width / rect.width);
  const y = (e.clientY - rect.top) * (canvas.height / rect.height);

  // znajd≈∫ pionek obecnego gracza, w kt√≥rego klikniƒôto z tolerancjƒÖ
  const candidates = [];
  for (let i=0;i<state.tokens.length;i++) {
    const t = state.tokens[i];
    if (t.player !== state.current) continue;
    const [px,py] = getTokenPixelPosFromState(i);
    const dist = Math.hypot(px-x, py-y);
    if (dist <= CS*.28+6) candidates.push(i);
  }
  if (candidates.length===0) return;

  // sprawd≈∫ legalno≈õƒá ruchu
  const legal = legalMovesFor(state.current, state.die).map(m=>m.tokenIndex);
  const selected = candidates.find(i=>legal.includes(i));
  if (selected==null) return;

  // wykonaj ruch tego pionka
  const move = legalMovesFor(state.current, state.die).find(m=>m.tokenIndex===selected);
  await performMove(move);
});

// UI ‚Äì przyciski
UI.rollBtn.addEventListener('click', rollDie);
UI.restartBtn.addEventListener('click', ()=> newGame(parseInt(UI.playersSelect.value,10)));
UI.playersSelect.addEventListener('change', ()=> newGame(parseInt(UI.playersSelect.value,10)));
UI.stacking.addEventListener('change', ()=>{
  state.stackingAllowed = UI.stacking.checked;
  draw();
});

// Pasek postƒôpu do zwyciƒôstwa: liczba pionk√≥w na homeIndex=5
function updateProgressBars() {
  for (let p=0;p<4;p++) {
    const bar = UI.pbars[p];
    if (!bar) continue;
    const total = TOKENS_PER_PLAYER;
    let inGoal = 0;
    for (const t of state.tokens) {
      if (t.player===p && t.posType==='home' && t.homeIndex===5) inGoal++;
    }
    const pct = (inGoal/total)*100;
    bar.style.width = pct + '%';
  }
}

// Start
newGame(4);
draw();
</script>
</body>
</html>
