<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>LEPSZELUDOBYMATEUSZ</title>
<meta name="description" content="Jednoplikowa gra Ludo (Ludo Club style) ‚Äî 2‚Äì4 graczy, offline, UNDO, autozapis, d≈∫wiƒôki, prosty bot.">
<style>
  :root{
    --bg:#0b0f1b;--panel:#12172b;--ink:#eef1ff;--muted:#a7add6;--brand:#7b7dff;
    --ok:#2ecc71;--warn:#f1c40f;--danger:#e74c3c;
  }
  *{box-sizing:border-box} html,body{height:100%}
  body{margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif;background:
    radial-gradient(1200px 600px at 70% -10%,#1a2141,#0b0f1b 56%,#070a14 100%);color:var(--ink)}
  header{position:sticky;top:0;background:#0a0e1e;border-bottom:1px solid #111735;z-index:10}
  .bar{max-width:1200px;margin:auto;padding:10px 14px;display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .title{font-weight:800;letter-spacing:.2px}
  .pill{background:#0e1430;border:1px solid #20285b;color:#cfd3ff;border-radius:999px;padding:6px 10px;font-size:12px}
  .wrap{max-width:1200px;margin:12px auto;padding:0 12px;display:grid;grid-template-columns:1fr 360px;gap:12px}
  #stage{background:#0c1227;border:1px solid #1a2150;border-radius:16px;padding:10px;display:flex;justify-content:center;align-items:center}
  canvas{width:min(92vw,820px);height:auto;aspect-ratio:1/1;background:#fff;border-radius:14px;box-shadow:0 24px 80px rgba(0,0,0,.35)}
  aside{background:var(--panel);border:1px solid #1a2150;border-radius:16px;padding:14px;display:flex;flex-direction:column;gap:12px}
  button,select,input[type=checkbox]{background:#0f1536;color:var(--ink);border:1px solid #273070;border-radius:12px;padding:10px 12px;font-size:14px}
  button{cursor:pointer;transition:.15s transform,.15s opacity}
  button:hover{transform:translateY(-1px)}
  button:disabled{opacity:.5;cursor:not-allowed;transform:none}
  .row{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
  .grow{flex:1} .muted{color:var(--muted);font-size:12px}
  .k6{width:46px;height:46px;border-radius:10px;background:#fff;border:2px solid #0a0a0a;display:grid;place-items:center;color:#0a0a0a;font-weight:800}
  .status{background:#0f1739;border:1px solid #23307a;border-radius:12px;padding:10px;line-height:1.35;font-size:14px}
  .dot{width:14px;height:14px;border-radius:50%;display:inline-block;border:1px solid rgba(0,0,0,.2);vertical-align:middle;margin-right:6px}
  .c-red{background:#e74c3c}.c-blue{background:#3498db}.c-green{background:#2ecc71}.c-yellow{background:#f1c40f}
  .barline{height:8px;background:#0d1445;border:1px solid #253086;border-radius:999px;overflow:hidden}
  .barline>div{height:100%;background:linear-gradient(90deg,#6c76ff,#9a6bff);width:0%}
  .sep{height:1px;background:#1a2150;margin:4px 0}
  footer{color:#8e94c3;text-align:center;padding:10px 0 20px;font-size:12px}
  @media (max-width:980px){.wrap{grid-template-columns:1fr}}
</style>
</head>
<body>
<header>
  <div class="bar">
    <div class="title">üé≤ LEPSZELUDO ‚Äî <b>SUCHYAMP Edition</b></div>
    <span class="pill">LEPSZELUDO</span>
    <span class="pill">2‚Äì4 graczy</span>
    <span class="pill">Kliknij pionek ‚Üí ruch</span>
  </div>
</header>

<main class="wrap">
  <section id="stage">
    <canvas id="cv" width="900" height="900"></canvas>
  </section>

  <aside>
    <div class="row">
      <label>üë• Gracze</label>
      <select id="players">
        <option>2</option><option>3</option><option selected>4</option>
      </select>
      <button id="new">üîÅ Nowa gra</button>
      <button id="undo">‚Ü∂ Cofnij</button>
    </div>
    <div class="row">
      <button id="roll">üé≤ Rzuƒá</button>
      <div class="k6" id="die">‚Äì</div>
      <label class="row" title="Dwa w≈Çasne pionki mogƒÖ staƒá na jednym polu.">
        <input type="checkbox" id="stack" checked> Wie≈ºe 
      </label>
      <label class="row" title="Prosty przeciwnik sterowany przez AI (gra jako ostatni gracz).">
        <input type="checkbox" id="bot"> Bot dla ostatniego
      </label>
      <label class="row" title="W≈ÇƒÖcz/wy≈ÇƒÖcz d≈∫wiƒôki.">
        <input type="checkbox" id="sfx" checked> D≈∫wiƒôki
      </label>
    </div>

    <div class="status" id="status">
      Tura: <b id="turn">Czerwony</b><br>
      Rzut: <b id="rollInfo">‚Äì</b><br>
      <span class="muted">Rzuƒá kostkƒÖ potem kliknij pod≈õwietlony pionek.</span>
    </div>

    <div>
      <div class="row"><b>Postƒôp (meta = 4 pionki)</b></div>
      <div class="row"><span class="dot c-red"></span> Czerwony <div class="barline grow"><div id="pb0"></div></div></div>
      <div class="row"><span class="dot c-blue"></span> Niebieski <div class="barline grow"><div id="pb1"></div></div></div>
      <div class="row"><span class="dot c-green"></span> Zielony <div class="barline grow"><div id="pb2"></div></div></div>
      <div class="row"><span class="dot c-yellow"></span> ≈ª√≥≈Çty <div class="barline grow"><div id="pb3"></div></div></div>
    </div>

    <div class="sep"></div>
    <div class="muted">
      Zasady: <br>‚Ä¢ 6 = wyj≈õcie z bazy + dodatkowy rzut (je≈õli wykonasz ruch).<br>
      
      
    </div>
  </aside>
</main>

<footer>Made by SUCHYAMP</footer>

<script>
const CV = document.getElementById('cv');
const CTX = CV.getContext('2d');
const UI = {
  players: document.getElementById('players'),
  new:     document.getElementById('new'),
  undo:    document.getElementById('undo'),
  roll:    document.getElementById('roll'),
  die:     document.getElementById('die'),
  status:  document.getElementById('status'),
  turn:    document.getElementById('turn'),
  rollInfo:document.getElementById('rollInfo'),
  pbars:   [0,1,2,3].map(i=>document.getElementById('pb'+i)),
  stack:   document.getElementById('stack'),
  bot:     document.getElementById('bot'),
  sfx:     document.getElementById('sfx'),
};
const COLORS = ['#e74c3c','#3498db','#2ecc71','#f1c40f'];
const NAMES  = ['Czerwony','Niebieski','Zielony','≈ª√≥≈Çty'];
const RING_COUNT = 52;
const TOKENS_PER = 4;
const HOME_LEN   = 6;
const START_AT   = [0,13,26,39];
const SAFE_EXTRA = [8,21,34,47];
const SAFE_SET   = new Set([...START_AT,...SAFE_EXTRA]);

const W = CV.width, H = CV.height;
const CX = W/2, CY = H/2;
const R_OUT = Math.min(W,H)*0.39;
const R_IN  = Math.min(W,H)*0.31;
const RING_POS = (()=>{
  const pts=[]; const startAngle = Math.PI*1.25;
  for (let i=0;i<RING_COUNT;i++){
    const a = startAngle - i*(2*Math.PI/RING_COUNT);
    const r = R_OUT;
    pts.push([CX + r*Math.cos(a), CY + r*Math.sin(a)]);
  } return pts;
})();
const HOME_POS = [0,1,2,3].map(p=>{
  const [sx,sy] = RING_POS[START_AT[p]];
  const vx = CX - sx, vy = CY - sy;
  const steps=[];
  for (let i=1;i<=HOME_LEN;i++){
    const t = i/(HOME_LEN+1);
    const x = sx + vx*t, y = sy + vy*t;
    steps.push([x,y]);
  } return steps;
});
const BASE_POS = (()=>{
  const rad = Math.min(W,H)*0.26, offs=[[-1,-1],[+1,-1],[-1,+1],[+1,+1]];
  return [0,1,2,3].map(p=>{
    const a = (Math.PI/4) + p*(Math.PI/2);
    const bx = CX + rad*Math.cos(a), by = CY + rad*Math.sin(a);
    const arr=[]; for (let i=0;i<4;i++) arr.push([bx + offs[i][0]*22, by + offs[i][1]*22]);
    return arr;
  });
})();

let S=null, HISTORY=[];
const SFX = {
  roll: mkBeep(220, 0.07),
  hit : mkBeep(520, 0.06),
  step: mkBeep(360, 0.03),
  win : mkBeep(660, 0.25)
};
function mkBeep(freq=440, dur=0.1){
  const ctx = new (window.AudioContext||window.webkitAudioContext)();
  return ()=>{
    if(!UI.sfx.checked) return;
    const o=ctx.createOscillator(), g=ctx.createGain();
    o.type='triangle'; o.frequency.value=freq;
    o.connect(g); g.connect(ctx.destination);
    g.gain.value=0.001; const t0=ctx.currentTime;
    g.gain.exponentialRampToValueAtTime(0.2, t0+0.01);
    g.gain.exponentialRampToValueAtTime(0.001, t0+dur);
    o.start(); o.stop(t0+dur+0.01);
  };
}

function newGame(nPlayers=4){
  S={ nPlayers, current:0, die:null, rolled:false, winner:null, stack:UI.stack.checked, tokens:[] };
  for (let p=0;p<nPlayers;p++) for (let i=0;i<TOKENS_PER;i++) S.tokens.push({player:p,pos:'base',ring:null,home:null,base:i});
  HISTORY=[]; syncUI(); draw(); save();
}
function syncUI(){
  UI.turn.textContent = NAMES[S.current];
  UI.rollInfo.textContent = S.die ?? '‚Äì';
  UI.die.textContent = S.die ?? '‚Äì';
  for (let p=0;p<4;p++){
    const bar=UI.pbars[p]; if(!bar) continue;
    let inGoal=0; for (const t of S.tokens) if (t.player===p && t.pos==='home' && t.home===5) inGoal++;
    bar.style.width = (inGoal/TOKENS_PER)*100 + '%';
  }
}
function roll(){
  if (S.winner!=null || S.rolled) return;
  diceAnim().then(n=>{
    S.die=n; S.rolled=true; syncUI();
    if (legalMovesFor(S.current,n).length===0){ flash(`Brak ruch√≥w dla ${NAMES[S.current]}.`); setTimeout(nextTurn,700); }
    else { flash(`Wybierz pionek (${NAMES[S.current]}).`); maybeBot(); }
    draw(); save();
  });
}
function legalMovesFor(player, die){
  const L=[]; const start=START_AT[player];
  for (let i=0;i<S.tokens.length;i++){
    const t=S.tokens[i]; if (t.player!==player) continue;
    if (t.pos==='base'){ if (die===6 && canLandRing(player,start)) L.push({i,kind:'enter',to:start}); }
    else if (t.pos==='ring'){
      const stepsToStart=((start - t.ring - 1 + RING_COUNT) % RING_COUNT) + 1;
      if (die>stepsToStart){
        const h = die - stepsToStart - 1; if (h<=5 && canLandHome(player,h)) L.push({i,kind:'tohome',to:h});
      } else {
        const to=(t.ring+die)%RING_COUNT; if (canLandRing(player,to)) L.push({i,kind:'ring',to});
      }
    } else if (t.pos==='home'){
      const to=t.home+die; if (to<=5 && canLandHome(player,to)) L.push({i,kind:'home',to});
    }
  } return L;
}
function tokensOnRing(idx){ const out=[]; for (let i=0;i<S.tokens.length;i++){ const t=S.tokens[i]; if (t.pos==='ring' && t.ring===idx) out.push(i);} return out;}
function tokensInHome(player,h){ const out=[]; for (let i=0;i<S.tokens.length;i++){ const t=S.tokens[i]; if (t.player===player && t.pos==='home' && t.home===h) out.push(i);} return out;}
function canLandRing(player,idx){
  const occ=tokensOnRing(idx); if (!occ.length) return true;
  const same=occ.every(i=>S.tokens[i].player===player);
  if (same) return S.stack;
  if (SAFE_SET.has(idx)) return false;
  return true;
}
function canLandHome(player,h){ return tokensInHome(player,h).length===0; }

async function perform(move){
  if (S.winner!=null) return; pushHistory();
  const t=S.tokens[move.i];
  if (move.kind==='enter'){ await animateMove(()=>setTokenRing(t,START_AT[t.player])); }
  else if (move.kind==='ring'){
    const steps=(move.to - t.ring + RING_COUNT) % RING_COUNT || RING_COUNT;
    await animateAdvanceRing(t,steps); t.ring=move.to;
  } else if (move.kind==='tohome'){
    const start=START_AT[t.player];
    const stepsToStart=((start - t.ring - 1 + RING_COUNT) % RING_COUNT) + 1;
    await animateAdvanceRing(t,stepsToStart);
    await animateEnterHome(t,move.to); t.pos='home'; t.ring=null; t.home=move.to;
  } else if (move.kind==='home'){
    await animateAdvanceHome(t,t.home,move.to); t.home=move.to;
  }
  if (t.pos==='ring' && !SAFE_SET.has(t.ring)){
    const occ=tokensOnRing(t.ring).filter(i=>S.tokens[i].player!==t.player);
    if (occ.length){ SFX.hit(); for (const i of occ) sendToBase(S.tokens[i]); flash(`üí• ${NAMES[t.player]} bije przeciwnika!`); }
  }
  if (checkWin(t.player)){ S.winner=t.player; SFX.win(); flash(`üèÜ Wygrywa ${NAMES[t.player]}!`); }
  const wasSix=(S.die===6); S.die=null; S.rolled=false;
  if (wasSix && S.winner==null) flash(`${NAMES[S.current]} ma dodatkowy rzut za ‚Äû6‚Äù.`);
  else nextTurn();
  syncUI(); draw(); save();
}
function checkWin(p){ let n=0; for (const t of S.tokens) if (t.player===p && t.pos==='home' && t.home===5) n++; return n===TOKENS_PER; }
function nextTurn(){ S.current=(S.current+1)%S.nPlayers; syncUI(); }
function sendToBase(t){
  const used=new Set(S.tokens.filter(x=>x.player===t.player && x.pos==='base').map(x=>x.base));
  let slot=0; while(used.has(slot)&&slot<4) slot++; t.pos='base'; t.ring=null; t.home=null; t.base=slot%4;
}
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }
async function diceAnim(){ SFX.roll(); let last=1; for (let i=0;i<12;i++){ last=1+Math.floor(Math.random()*6); UI.die.textContent=last; await sleep(50+i*12);} return last; }
async function animateAdvanceRing(token,steps){
  for (let s=0;s<steps;s++){
    const from=getTokenPos(token);
    token.ring = (token.ring==null?START_AT[token.player]: (token.ring+1)%RING_COUNT);
    token.pos='ring'; const to=getTokenPos(token);
    await animateGhost(from,to,9,10); SFX.step();
  }
}
async function animateEnterHome(token,toHome){
  const startPos=[...RING_POS[START_AT[token.player]]];
  token.pos='home'; token.ring=null; token.home=0;
  await animateGhost(startPos, HOME_POS[token.player][0], 9, 10);
  for (let i=1;i<=toHome;i++){
    const from=HOME_POS[token.player][i-1], to=HOME_POS[token.player][i];
    await animateGhost(from,to,9,10); SFX.step();
  }
}
async function animateAdvanceHome(token,from,to){
  for (let i=from+1;i<=to;i++){
    await animateGhost(HOME_POS[token.player][i-1], HOME_POS[token.player][i], 9, 10); SFX.step();
  }
}
async function animateMove(mut){ const before=getTokenPosPreview(); mut(); const after=getTokenPosPreview(); await animateGhost(before,after,10,12); }
function getTokenPos(t){ if (t.pos==='ring') return RING_POS[t.ring]; if (t.pos==='home') return HOME_POS[t.player][t.home]; if (t.pos==='base') return BASE_POS[t.player][t.base]; }
function getTokenPosPreview(){ const pts=[]; for (const t of S.tokens) pts.push(getTokenPos(t)); return pts[0]; }
async function animateGhost(from,to,steps=8,ms=12){
  for (let i=1;i<=steps;i++){ const k=i/steps; const x=from[0]+(to[0]-from[0])*k; const y=from[1]+(to[1]-from[1])*k; draw({ghost:{x,y}}); await sleep(ms); }
}
function draw(opt={}){
  CTX.clearRect(0,0,W,H);
  CTX.save(); CTX.globalAlpha=0.08; CTX.fillStyle='#6f77ff';
  CTX.beginPath(); CTX.arc(CX,CY, R_OUT+30,0,Math.PI*2); CTX.fill();
  CTX.globalAlpha=0.06; CTX.beginPath(); CTX.arc(CX,CY, R_IN-18,0,Math.PI*2); CTX.fill(); CTX.restore();
  for (let i=0;i<RING_COUNT;i++){ const [x,y]=RING_POS[i]; const safe=SAFE_SET.has(i); drawCell(x,y, safe? '#eef2ff':'#ffffff', safe? '#c9d2ff':'#cfcfcf'); }
  for (let p=0;p<S.nPlayers;p++) for (let h=0;h<HOME_LEN;h++){ const [x,y]=HOME_POS[p][h]; const goal=(h===HOME_LEN-1); drawCell(x,y, goal? lighten(COLORS[p],.75):'#f8f9ff', '#b9c3ea'); }
  for (let p=0;p<S.nPlayers;p++) for (let b=0;b<4;b++){ const [x,y]=BASE_POS[p][b]; drawCell(x,y,'#f7f8ff','#b9c0ea',12); CTX.save(); CTX.globalAlpha=.20; CTX.fillStyle=lighten(COLORS[p],.2); CTX.beginPath(); CTX.arc(x,y,14,0,Math.PI*2); CTX.fill(); CTX.restore(); }
  if (S.rolled && S.winner==null){
    const L=legalMovesFor(S.current,S.die); const set=new Set(L.map(m=>m.i));
    for (const i of set){ const t=S.tokens[i]; const [x,y]=getTokenPos(t); CTX.strokeStyle='#7d7fff'; CTX.lineWidth=4; CTX.beginPath(); CTX.arc(x,y,20,0,Math.PI*2); CTX.stroke(); }
  }
  const ghost=opt.ghost;
  for (let i=0;i<S.tokens.length;i++){
    const t=S.tokens[i]; if (t.player>=S.nPlayers) continue;
    let [x,y]=getTokenPos(t);
    if (ghost && i===selectNearestTokenIndex(ghost.x,ghost.y,S.current)) { x=ghost.x; y=ghost.y; }
    const stack=stackedHere(t); const idx=stack.indexOf(i); const lift=-6*idx;
    drawPawn(x,y+lift,COLORS[t.player]);
  }
  CTX.save(); CTX.globalAlpha=.08; CTX.fillStyle='#7b7dff';
  CTX.beginPath(); CTX.arc(CX,CY,44,0,Math.PI*2); CTX.fill(); CTX.restore();
}
function drawCell(x,y,fill,stroke,r=10){ CTX.save(); CTX.fillStyle=fill; CTX.strokeStyle=stroke; CTX.lineWidth=1.5; roundRect(x-18,y-18,36,36,r,true,true); CTX.restore(); }
function drawPawn(x,y,color){
  CTX.save(); CTX.fillStyle='rgba(0,0,0,.2)'; CTX.beginPath(); CTX.ellipse(x,y+10,16,7,0,0,Math.PI*2); CTX.fill(); CTX.restore();
  const r=16; const grd=CTX.createRadialGradient(x-r/2,y-r/2,r*.2,x,y,r); grd.addColorStop(0,lighten(color,.35)); grd.addColorStop(1,color);
  CTX.fillStyle=grd; CTX.strokeStyle='#111'; CTX.lineWidth=1.5; CTX.beginPath(); CTX.arc(x,y,r,0,Math.PI*2); CTX.fill(); CTX.stroke();
}
function roundRect(x,y,w,h,r,fill,stroke){ if (w<2*r) r=w/2; if (h<2*r) r=h/2; CTX.beginPath(); CTX.moveTo(x+r,y); CTX.arcTo(x+w,y,x+w,y+h,r); CTX.arcTo(x+w,y+h,x,y+h,r); CTX.arcTo(x,y+h,x,y,r); CTX.arcTo(x,y,x+w,y,r); if (fill) CTX.fill(); if (stroke) CTX.stroke(); }
function lighten(hex,k){ const c=parseInt(hex.slice(1),16); let r=(c>>16)&255,g=(c>>8)&255,b=c&255; r=Math.min(255,r+(255-r)*k); g=Math.min(255,g+(255-g)*k); b=Math.min(255,b+(255-b)*k); return `rgb(${r|0},${g|0},${b|0})`; }
CV.addEventListener('click', async (e)=>{
  if (!S.rolled || S.winner!=null) return;
  const {x,y}=toCanvasPoint(e); const idx=selectNearestTokenIndex(x,y,S.current); if (idx==null) return;
  const L=legalMovesFor(S.current,S.die); const move=L.find(m=>m.i===idx); if (!move) return; await perform(move);
});
function selectNearestTokenIndex(x,y,player){
  let best=null,bd=9999;
  for (let i=0;i<S.tokens.length;i++){ const t=S.tokens[i]; if (t.player!==player) continue;
    const [px,py]=getTokenPos(t); const d=Math.hypot(px-x,py-y); if (d<bd && d<=28){ bd=d; best=i; } }
  return best;
}
function toCanvasPoint(e){ const r=CV.getBoundingClientRect(); return { x:(e.clientX-r.left)*(CV.width/r.width), y:(e.clientY-r.top)*(CV.height/r.height) }; }
function pushHistory(){ HISTORY.push(JSON.stringify(S)); if (HISTORY.length>50) HISTORY.shift(); }
function undo(){ const prev=HISTORY.pop(); if (!prev) return; S=JSON.parse(prev); syncUI(); draw(); save(); }
function save(){ try{ localStorage.setItem('ludo.mateusz.save', JSON.stringify(S)); }catch{} }
function load(){ try{ const raw=localStorage.getItem('ludo.mateusz.save'); if (!raw) return false; const st=JSON.parse(raw); if (!st || !Array.isArray(st.tokens)) return false; S=st; HISTORY=[]; syncUI(); draw(); return true; }catch{ return false; } }
function maybeBot(){
  if (!UI.bot.checked) return;
  if (S.current !== S.nPlayers-1) return;
  setTimeout(()=>{
    const L=legalMovesFor(S.current,S.die); if (!L.length) return;
    const score=m=>{ if (m.kind==='ring'){ const enemies=tokensOnRing(m.to).filter(i=>S.tokens[i].player!==S.current); if (enemies.length && !SAFE_SET.has(m.to)) return 100; }
                     if (m.kind==='tohome') return 80; if (m.kind==='home') return 60; if (m.kind==='enter') return 50; return 10; };
    L.sort((a,b)=>score(b)-score(a)); perform(L[0]);
  }, 380);
}
function flash(text){ UI.status.innerHTML = `Tura: <b>${NAMES[S.current]}</b><br>Rzut: <b>${S.die ?? '‚Äì'}</b><br>${text}`; }
function setTokenRing(token,idx){ token.pos='ring'; token.ring=idx; token.home=null; }
function stackedHere(tkn){
  if (tkn.pos==='ring') return S.tokens.map((tt,i)=>({tt,i})).filter(o=>o.tt.pos==='ring'&&o.tt.ring===tkn.ring&&o.tt.player===tkn.player).map(o=>o.i);
  if (tkn.pos==='home') return S.tokens.map((tt,i)=>({tt,i})).filter(o=>o.tt.pos==='home'&&o.tt.home===tkn.home&&o.tt.player===tkn.player).map(o=>o.i);
  return S.tokens.map((tt,i)=>({tt,i})).filter(o=>o.tt.pos==='base'&&o.tt.base===tkn.base&&o.tt.player===tkn.player).map(o=>o.i);
}
UI.new.addEventListener('click',()=> newGame(parseInt(UI.players.value,10)));
UI.players.addEventListener('change',()=> newGame(parseInt(UI.players.value,10)));
UI.stack.addEventListener('change',()=>{ S.stack = UI.stack.checked; draw(); save(); });
UI.roll.addEventListener('click', roll);
UI.undo.addEventListener('click', undo);
UI.bot.addEventListener('change',()=> save());
UI.sfx.addEventListener('change',()=>{});
if(!load()) newGame(4);
</script>
</body>
</html>
